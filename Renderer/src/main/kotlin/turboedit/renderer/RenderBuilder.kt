package turboedit.renderer

import net.bramp.ffmpeg.FFmpeg
import net.bramp.ffmpeg.FFmpegExecutor
import net.bramp.ffmpeg.FFprobe
import net.bramp.ffmpeg.builder.FFmpegBuilder
import org.apache.commons.io.FileUtils
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import turboedit.shared.project.Project
import java.io.File
import java.io.IOException
import java.nio.file.Path
import java.time.Duration
import java.util.concurrent.TimeUnit

object RenderBuilder {
    private val logger: Logger = LoggerFactory.getLogger(RenderBuilder::class.java)

    @Throws(IOException::class)
    fun buildFFMPEG(
        project: Project,
        timelineIndex: Int,
        ffmpeg: FFmpeg,
        ffprobe: FFprobe,
        projectPath: String,
        output: String?
    ): RenderItem {
        val basePath = Path.of(projectPath).parent
        val fileContent = ArrayList<String?>()
        val subThreads = ArrayList<Thread?>()
        val executor = FFmpegExecutor(ffmpeg, ffprobe)
        val timeline = project.timelines!![timelineIndex]

        val paths = ArrayList<String?>()

        fileContent.add("# Generated by TurboEdit Render Server")
        for (clip in timeline!!.clips!!) {
            val file = project.files!![clip!!.file]
            val index = subThreads.size

            val thread = Thread(Runnable {
                val path = Path.of(basePath.toString(), file!!.path).normalize().toAbsolutePath().toString()

                if (clip.startTime == 0L && clip.endTime == 0L) {
                    fileContent.add("file '$path'")
                } else {
                    try {
                        /*       var probe = ffprobe.probe(path);
                    FFmpegStream stream = null;

                    for (var cStream : probe.getStreams()) {
                        if (cStream.codec_type != FFmpegStream.CodecType.VIDEO) continue;
                        stream = cStream;
                        break;
                    }*/

                        val tmpFile = File.createTempFile(
                            "tm_te_tmpv_" + index + "_",
                            "." + path.split("\\.".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[1]
                        )
                        paths.add(index, tmpFile.absolutePath)

                        val builder = FFmpegBuilder()
                            .setInput(path)
                            .setStartOffset(clip.startTime, TimeUnit.MILLISECONDS)
                            .addExtraArgs("-sseof", formatDuration(clip.endTime))
                            .addOutput(tmpFile.absolutePath)
                            .setAudioCodec("copy")
                            .setVideoCodec("copy")
                            .addExtraArgs("-map", "0")
                            .done()

                        val job = executor.createJob(builder)
                        job.run()

                        logger.info("SubRender-{} finished", index)
                    } catch (e: IOException) {
                        throw RuntimeException(e)
                    }
                }

                subThreads[index] = null

                try {
                    for (thr in subThreads) {
                        if (thr != null) break

                        subThreads.clear()
                    }
                } catch (e: Exception) {
                }
            })

            thread.setName("SubRender-" + subThreads.size)
            thread.start()

            subThreads.add(thread)

            try {
                Thread.sleep(200)
            } catch (e: InterruptedException) {
                throw RuntimeException(e)
            }
        }

        while (!subThreads.isEmpty()) {
            try {
                Thread.sleep(1000)
            } catch (e: InterruptedException) {
                throw RuntimeException(e)
            }
        }

        for (path in paths) {
            fileContent.add("file '$path'")
        }

        val tempFile = File.createTempFile("tm_te_" + project.name + "_concat_", ".txt")

        FileUtils.writeLines(tempFile, fileContent)

        val builder = FFmpegBuilder()
            .setFormat("concat")
            .addExtraArgs("-safe", "0")
            .setInput(tempFile.absolutePath)
            .overrideOutputFiles(true)
            .addOutput(output)
            .setStrict(FFmpegBuilder.Strict.EXPERIMENTAL)
            .setVideoCodec("copy")
            .setAudioCodec("copy").addExtraArgs("-map", "0")
            .done()

        paths.add(tempFile.absolutePath)

        return RenderItem(builder, paths)
    }

    fun formatDuration(millis: Long): String {
        val duration = Duration.ofMillis(millis)

        val hours = duration.toHours()
        val minutes = duration.toMinutes() % 60
        val seconds = duration.seconds % 60
        val ms = millis % 1000

        return String.format("%02d:%02d:%02d.%03d", hours, minutes, seconds, ms)
    }

    @JvmRecord
    data class RenderItem(val builder: FFmpegBuilder?, val deletions: ArrayList<String?>?)
}
